#include "scenes.hpp"
#include "OS/FileSystem/file.h"
#define DISPLAY_CONSOLE 1

#ifdef _DEBUG
    const char* gameName = "[DEBUG] EngineTest";
#else
    const char* gameName = "[RELEASE] EngineTest";
#endif

#include "Time/clock.h"

#include "Ext/ImGUI/imgui.h"

namespace ImGui
{
    void Image(const TexturePtr& tex)
    {
        ImGui::Image( (void*)&tex, { (F32)tex->getWidth(), (F32)tex->getHeight() });
    }

    void Image(const TexturePtr& tex, const Math::Vec2& size)
    {
        ImGui::Image((void*)&tex, { size.x, size.y });
    }
}

class ImGUIRenderComponent : public Components::IComponent
{
public:
    ImGUIRenderComponent() = default;
    virtual ~ImGUIRenderComponent() {}

    virtual void OnImGUI() = 0;

private:
    NULL_COPY_AND_ASSIGN(ImGUIRenderComponent)
};

class ImGUI : public Components::IComponent
{
public:
    ImGUI() = default;

    void addedToGameObject(GameObject* go) override
    {
        // IMGUI
        m_imguiContext = ImGui::CreateContext();
        ImGui::SetCurrentContext(m_imguiContext);
        ImGuiIO& io = ImGui::GetIO();

        // Build and load the texture atlas into a texture
        unsigned char* pixels = NULL;
        I32 width, height;
        io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
        m_fontAtlas = RESOURCES.createTexture2D(width, height, Graphics::TextureFormat::RGBA32, pixels);
        io.Fonts->TexID = &m_fontAtlas;

        // Mesh containing all the vertex/index data
        m_dynamicMesh = RESOURCES.createMesh();
        m_dynamicMesh->setBufferUsage(Graphics::BufferUsage::Frequently);

        // Retrieve GUI shader
        m_guiShader = ASSETS.getShader( "/shaders/gui.shader" );
        m_guiShader->setName("GUI");

        auto cam = go->getComponent<Components::Camera>();
        ASSERT(cam && "This component requires a camera!");
        cam->addCommandBuffer(&m_cmd, Components::CameraEvent::Overlay);

        m_orthoCamera.setRenderTarget(cam->getRenderTarget(), cam->isRenderingToScreen());
        m_orthoCamera.setCameraMode(Graphics::CameraMode::Orthographic);
        m_orthoCamera.setClearMode(Graphics::CameraClearMode::None);
    }

    ~ImGUI()
    {
        ImGui::DestroyContext(m_imguiContext);
    }

    void lateTick(Time::Seconds d) override
    {
        _UpdateIMGUI((F32)d);
        ImGui::NewFrame();
        for (auto renderComponent : getGameObject()->getComponents<ImGUIRenderComponent>())
            renderComponent->OnImGUI();
        ImGui::EndFrame();
        ImGui::Render();

        m_cmd.reset();
        m_cmd.setCamera(&m_orthoCamera);

        ImDrawData* draw_data = ImGui::GetDrawData();
        m_orthoCamera.setModelMatrix(DirectX::XMMatrixIdentity());
        m_orthoCamera.setOrthoParams(draw_data->DisplayPos.x, draw_data->DisplayPos.x + draw_data->DisplaySize.x,
                                     draw_data->DisplayPos.y + draw_data->DisplaySize.y, draw_data->DisplayPos.y, 
                                     -1, 1);

        ArrayList<Math::Vec3>   vertices;
        ArrayList<Math::Vec2>   uvs;
        ArrayList<Color>        colors;

        I32 subMesh = 0;
        U32 baseVertex = 0;
        for (int n = 0; n < draw_data->CmdListsCount; n++)
        {
            const ImDrawList* cmd_list = draw_data->CmdLists[n];
            const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
            const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui

            for (I32 v = 0; v < cmd_list->VtxBuffer.Size; v++)
            {
                auto& vertex = vtx_buffer[v];
                vertices.push_back({ vertex.pos.x, vertex.pos.y, 0.0f });
                uvs.push_back({ vertex.uv.x, vertex.uv.y });
                colors.push_back(Color(vertex.col));
            }

            for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
            {
                const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
                if (pcmd->UserCallback)
                {
                    pcmd->UserCallback(cmd_list, pcmd);
                }
                else
                {
                    ArrayList<U32> indices(pcmd->ElemCount);
                    for (U32 i = 0; i < pcmd->ElemCount; i++)
                        indices[i] = idx_buffer[i];

                    ImVec2 pos = draw_data->DisplayPos;
                    Math::Rect r = { (long)(pcmd->ClipRect.x - pos.x), (long)(pcmd->ClipRect.y - pos.y), 
                                     (long)(pcmd->ClipRect.z - pos.x), (long)(pcmd->ClipRect.w - pos.y) };
                    m_cmd.setScissor(r);

                    // Create a new material and set texture
                    auto mat = RESOURCES.createMaterial(m_guiShader);

                    TexturePtr* texture = static_cast<TexturePtr*>( pcmd->TextureId );
                    mat->setTexture( "tex", *texture );

                    m_dynamicMesh->setIndices(indices, subMesh, Graphics::MeshTopology::Triangles, baseVertex);
                    m_cmd.drawMesh(m_dynamicMesh, mat, DirectX::XMMatrixIdentity(), subMesh);
                    subMesh++;
                }
                idx_buffer += pcmd->ElemCount;
            }
            baseVertex += cmd_list->VtxBuffer.Size;
        }

        if (vertices.size() > 0)
        {
            m_dynamicMesh->setVertices(vertices);
            m_dynamicMesh->setColors(colors);
            m_dynamicMesh->setUVs(uvs);

            Locator::getRenderer().dispatch(m_cmd);
        }
    }

private:
    ImGuiContext*           m_imguiContext = nullptr;
    Texture2DPtr            m_fontAtlas;
    MeshPtr                 m_dynamicMesh;
    ShaderPtr               m_guiShader;
    Graphics::CommandBuffer m_cmd;
    Graphics::Camera        m_orthoCamera;

    void _UpdateIMGUI(F32 delta)
    {
        ImGui::SetCurrentContext(m_imguiContext);
        ImGuiIO& io = ImGui::GetIO();
        io.DeltaTime = delta;

        auto& rt = getGameObject()->getComponent<Components::Camera>()->getRenderTarget();
        io.DisplaySize.x = (F32)rt->getWidth();
        io.DisplaySize.y = (F32)rt->getHeight();
        io.MousePos = { (F32)MOUSE.getMousePos().x, (F32)MOUSE.getMousePos().y };
        io.MouseDown[0] = MOUSE.isKeyDown(MouseKey::LButton);
        io.MouseDown[1] = MOUSE.isKeyDown(MouseKey::RButton);
        io.MouseWheel = MOUSE.getWheelDelta();
    }

    NULL_COPY_AND_ASSIGN(ImGUI)
};

class GUIImage : public ImGUIRenderComponent
{
    TexturePtr m_tex;
public:
    GUIImage(TexturePtr tex) : m_tex(tex) {}

    void OnImGUI() override
    {
        ImGui::Image(m_tex);
    }
};

class GUIDemoWindow : public ImGUIRenderComponent
{
public:
    void OnImGUI() override
    {
        ImGui::ShowDemoWindow();
    }
};


//----------------------------------------------------------------------
// SCENES
//----------------------------------------------------------------------

class TestScene : public IScene
{
    Components::Camera* cam;

public:
    TestScene() : IScene("TestScene") {}

    void init() override
    {
        // Camera 1
        auto go = createGameObject("Camera");
        cam = go->addComponent<Components::Camera>();
        go->getComponent<Components::Transform>()->position = Math::Vec3(0, 3, -8);
        go->addComponent<Components::FPSCamera>(Components::FPSCamera::MAYA, 0.1f);
        createGameObject("Grid")->addComponent<GridGeneration>(20);
        go->addComponent<ImGUI>();
        go->addComponent<GUIImage>(ASSETS.getTexture2D("/textures/nico.jpg"));
        go->addComponent<GUIDemoWindow>();

        //auto go2 = createGameObject("Camera");
        //auto renderTex = RESOURCES.createRenderTexture(1024, 720, Graphics::DepthFormat::None, Graphics::TextureFormat::BGRA32, 2, Graphics::MSAASamples::One);
        //auto cam2 = go2->addComponent<Components::Camera>(renderTex);
        //cam2->setRenderTarget(renderTex);
        //go2->addComponent<ImGUI>();
        //go2->addComponent<GUIDemoWindow>();

        //auto depthMapGO = createGameObject("DepthMapGO");
        //auto depthMapMaterial = RESOURCES.createMaterial(ASSETS.getShader("/shaders/tex.shader"));
        //depthMapMaterial->setTexture("tex", cam2->getRenderTarget()->getColorBuffer());
        //depthMapMaterial->setColor("tintColor", Color::WHITE);
        //depthMapGO->addComponent<Components::MeshRenderer>(Core::MeshGenerator::CreatePlane(), depthMapMaterial);
        //depthMapGO->getTransform()->position = { 0, 1, 0 };

        LOG("TestScene initialized!", Color::RED);
    }

    void tick(Time::Seconds d) override
    {
        if (KEYBOARD.wasKeyPressed(Key::M))
        {
            static int index = 0;
            U32 mscounts[]{ 1,2,4,8 };
            U32 newmscount = mscounts[index];
            index = (index + 1) % (sizeof(mscounts) / sizeof(int));
            cam->setMultiSamples( (Graphics::MSAASamples) newmscount );
            LOG("New Multisample-Count: " + TS(newmscount), Color::GREEN);
        }
    }

    void shutdown() override {
        LOG("TestScene Shutdown!", Color::RED); 
    }
};


//----------------------------------------------------------------------
// GAME
//----------------------------------------------------------------------

class Game : public IGame
{
    const F64 duration = 1000;
    Time::Clock clock;

public:
    Game() : clock( duration ) {}

    //----------------------------------------------------------------------
    void init() override 
    {
        LOG( "Init game..." );
        getWindow().setCursor( "/cursors/Areo Cursor Red.cur" );
        getWindow().setIcon( "/engine/icon.ico" );
        gLogger->setSaveToDisk( false );

        Locator::getEngineClock().setInterval([=] {
            U32 fps = PROFILER.getFPS();
            F64 delta = (1000.0 / fps);
            String newTitle = String(gameName) + " | Time: " + TS(TIME.getTime().value) + " | Delta: " + TS(delta) + "ms (" + TS(fps) + " FPS)";
            Locator::getWindow().setTitle(newTitle.c_str());
        }, 1000);

        ASSETS.setHotReloading(true);

        Locator::getRenderer().setVSync(true);
        Locator::getRenderer().setGlobalFloat(SID("_Ambient"), 0.5f);

        Locator::getSceneManager().LoadSceneAsync(new TestScene());
    }

    //----------------------------------------------------------------------
    void tick(Time::Seconds delta) override
    {
        //clock.tick( delta );
        //LOG( TS( clock.getTime().value ) );
        //auto time = clock.getTime();

        if (KEYBOARD.wasKeyPressed(Key::One))
            Locator::getSceneManager().LoadSceneAsync(new VertexGenScene);
        if (KEYBOARD.wasKeyPressed(Key::Two))
            Locator::getSceneManager().LoadSceneAsync(new ScenePostProcessMultiCamera);
        if (KEYBOARD.wasKeyPressed(Key::Three))
            Locator::getSceneManager().LoadSceneAsync(new SceneMirror);
        if (KEYBOARD.wasKeyPressed(Key::Four))
            Locator::getSceneManager().LoadSceneAsync(new ManyObjectsScene(10000));
        if (KEYBOARD.wasKeyPressed(Key::Five))
            Locator::getSceneManager().LoadSceneAsync(new BlinnPhongLightingScene());
        if (KEYBOARD.wasKeyPressed(Key::Six))
            Locator::getSceneManager().LoadSceneAsync(new ScenePBRSpheres());
        if (KEYBOARD.wasKeyPressed(Key::Seven))
            Locator::getSceneManager().LoadSceneAsync(new TransparencyScene());
        if (KEYBOARD.wasKeyPressed(Key::Eight))
            Locator::getSceneManager().LoadSceneAsync(new SponzaScene());
        if (KEYBOARD.wasKeyPressed(Key::Nine))
            Locator::getSceneManager().LoadSceneAsync(new ScenePBRPistol());
        if (KEYBOARD.wasKeyPressed(Key::Zero))
            Locator::getSceneManager().LoadSceneAsync(new TestScene());

        if (KEYBOARD.wasKeyPressed(Key::P))
            PROFILER.logGPU();

        if (KEYBOARD.wasKeyPressed(Key::F1))
            Locator::getRenderer().setGlobalMaterialActive("NONE");
        if (KEYBOARD.wasKeyPressed(Key::F2))
            Locator::getRenderer().setGlobalMaterialActive("Wireframe");

        if(KEYBOARD.isKeyDown(Key::Escape))
            terminate();
    }

    //----------------------------------------------------------------------
    void shutdown() override 
    {
        LOG( "Shutdown game..." );
    }
};

#if DISPLAY_CONSOLE

    int main()
    {
        Game game;
        game.start( gameName, 800, 600 );

        system("pause");
        return 0;
    }

#else

    #undef ERROR
    #include <Windows.h>

    int APIENTRY WinMain(HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPTSTR    lpCmdLine,
        int       nCmdShow)
    {
        Game game;
        game.start( gameName, 800, 600 );

        return 0;
    }

#endif



//class TestScene : public IScene
//{
//    Components::Camera* cam;
//public:
//    TestScene() : IScene("TestScene") {}
//
//    void init() override
//    {
//        // Camera 1
//        auto go = createGameObject("Camera");
//        cam = go->addComponent<Components::Camera>();
//        go->getComponent<Components::Transform>()->position = Math::Vec3(0, 3, -8);
//        go->addComponent<Components::FPSCamera>(Components::FPSCamera::MAYA, 0.1f);
//        //createGameObject("Grid")->addComponent<GridGeneration>(20);
//
//        auto planeMesh = Core::MeshGenerator::CreatePlane();
//        auto obj = createGameObject("GO");
//        obj->addComponent<Components::MeshRenderer>(planeMesh, ASSETS.getMaterial("/materials/blinn_phong/grass.material"));
//        obj->getTransform()->rotation *= Math::Quat(Math::Vec3::RIGHT, 90.0f);
//        obj->getTransform()->scale = { 20,20,20 };
//
//        auto obj2 = createGameObject("GO2");
//        obj2->addComponent<Components::MeshRenderer>(ASSETS.getMesh("/models/monkey.obj"), ASSETS.getMaterial("/materials/blinn_phong/monkey.material"));
//        obj2->getTransform()->position = { 5, 1, 0 };
//
//        auto cubeGO = createGameObject("GO3");
//        cubeGO->addComponent<Components::MeshRenderer>(Core::MeshGenerator::CreateCubeUV(0.3f), ASSETS.getMaterial("/materials/blinn_phong/cube.material"));
//        cubeGO->getTransform()->position = { 0.0f, 0.3001f, -3.0f };
//
//        Assets::MeshMaterialInfo matInfo;
//        auto treeMesh = ASSETS.getMesh("/models/tree/tree.obj", &matInfo);
//
//        auto treeGO = createGameObject("Tree");
//        auto mr = treeGO->addComponent<Components::MeshRenderer>(treeMesh);
//        //treeGO->getTransform()->scale = { 0.01f };
//
//        if (matInfo.isValid())
//        {
//            for (I32 i = 0; i < treeMesh->getSubMeshCount(); i++)
//            {
//                auto material = RESOURCES.createMaterial(ASSETS.getShader("/shaders/phong_shadow.shader"));
//                material->setFloat("uvScale", 1.0f);
//
//                for (auto& texture : matInfo[i].textures)
//                {
//                    switch (texture.type)
//                    {
//                    case Assets::MaterialTextureType::Albedo: material->setTexture("albedo", ASSETS.getTexture2D(texture.filePath)); break;
//                    case Assets::MaterialTextureType::Normal: material->setTexture("normalMap", ASSETS.getTexture2D(texture.filePath)); break;
//                    case Assets::MaterialTextureType::Shininess: break;
//                    case Assets::MaterialTextureType::Specular: break;
//                    }
//                }
//                mr->setMaterial(material, i);
//            }
//        }
//        //treeGO->addComponent<VisualizeNormals>(0.1f, Color::BLUE);
//
//        // LIGHTS
//        auto sun = createGameObject("Sun");
//        sun->addComponent<Components::DirectionalLight>(1.0f, Color::WHITE);
//        sun->getTransform()->rotation = Math::Quat::LookRotation(Math::Vec3{ 0,-1, 1 });
//        //sun->addComponent<ConstantRotation>(15.0f, 0.0f, 0.0f);
//
//        auto depthMapGO = createGameObject("DepthMapGO");
//        auto depthMapMaterial = RESOURCES.createMaterial(ASSETS.getShader("/shaders/tex.shader"));
//        depthMapMaterial->setTexture("tex", ASSETS.getTexture2D("/textures/nico.jpg"));
//        depthMapMaterial->setColor("tintColor", Color::WHITE);
//        depthMapGO->addComponent<Components::MeshRenderer>(Core::MeshGenerator::CreatePlane(), depthMapMaterial);
//        depthMapGO->getTransform()->position = { -5, 1, 0 };
//
//        // IMGUI
//        ImGui::CreateContext();
//        ImGuiIO& io = ImGui::GetIO(); (void)io;
//
//        ImGui::StyleColorsDark();
//
//        LOG("TestScene initialized!", Color::RED);
//    }
//
//    void tick(Time::Seconds d) override
//    {
//        if (KEYBOARD.wasKeyPressed(Key::M))
//        {
//            static int index = 0;
//            U32 mscounts[]{ 1,2,4,8 };
//            U32 newmscount = mscounts[index];
//            index = (index + 1) % (sizeof(mscounts) / sizeof(int));
//            cam->setMultiSamples((Graphics::MSAASamples) newmscount);
//            LOG("New Multisample-Count: " + TS(newmscount), Color::GREEN);
//        }
//    }
//
//    void shutdown() override { LOG("TestScene Shutdown!", Color::RED); }
//};
