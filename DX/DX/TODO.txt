

1.) Render arbitrary geometry
    > Setup the right pipeline (Different pipeline states)
    > Create/Upload a model to the GPU
        > Set Vertices / Indices from a model
    > Shaders
        > Hot-Reloading of shaders
    > Materials
		> Associated with a shader and uniform params cached on the cpu
	    > Push to GPU before rendering
	> Command Buffer
		> Stores Rendering Commands e.g.
			> DrawMesh(mesh, material, matrix)
	> Camera
		> View / Proj Matrix
		> As in unity, command buffer attached to different camera events?
		> Viewfrustum Culling

1.5) Debug Drawing
	> Render Lines / Boxes in wireframe

2.) Audio

3.) Physics
	> Box
	> RayCasting
	> Triangle/Ray Intersection

4.) (GUI Rendering)
	> Font
	> Images

<<<< Minecraft >>>>
	> World Generation
	> Physics 
		> Most likely just box collision, depends on how chunks are generated/stores


----------------------------------------------------------------------------------------
// Fetch all renderer components e.g. model-renderer
CRenderer renderer = scene.getRenderer();

foreach camera in scene
	// Command Buffers are attached to camera (Always one attached?)
	CommandBuffer cmd;

	// Command for setting necessary camera parameters
	cmd.setTargetTexture(camera->targetTexture);
	cmd.setCameraPerspective(camera->view, camera->fov, camera->zNear, camera->zFar, camera->clearColor);
	// cmd.setCameraOrtho(...);

	// Add optionally attached command buffer aswell
	foreach commandBuffer in camera->commandBuffers
		graphicsEngine->dispatch(commandBuffer)

	// Do viewfrustum culling with every renderer component and THIS CAMERA
	foreach renderer in renderer
		bool isVisible = renderer->Cull(camera);
		bool layerMatch = camera->layerMask & renderer->getLayerMask();
		if (isVisible && layerMatch)
			renderer->recordCommands(cmd); // cmd contains commands to render this specific renderer e.g. model

	// Execute render commands
	graphicsEngine->dispatch(cmd);
